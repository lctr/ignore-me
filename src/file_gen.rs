use std::{
    fs, io,
    path::{Path, PathBuf},
};

use crate::assets::Asset;

pub struct FileGen {
    assets: Vec<Asset>,
    target: Option<PathBuf>,
}

impl Default for FileGen {
    fn default() -> Self {
        Self {
            assets: vec![],
            target: None,
        }
    }
}

impl FileGen {
    pub const FILENAME: &'static str = ".gitignore";
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_assets(assets: impl IntoIterator<Item = Asset>) -> Self {
        let assets = assets.into_iter().fold(vec![], |mut a, c| {
            if !a.contains(&c) {
                a.push(c);
            }
            a
        });
        Self {
            assets,
            target: None,
        }
    }

    pub fn with_target(target: impl AsRef<Path>) -> Self {
        let mut this = Self {
            assets: vec![],
            target: None,
        };
        let path = target.as_ref();
        if path.is_dir() && path.exists() {
            this.target = Some(path.to_path_buf());
        }
        this
    }

    /// Creates an instance of `FileGen` containing the given assets
    /// with the provided `target` as the directory of the output
    /// file. If the provided `target` is not a directory (and/or does
    /// not exist), then it will be ignored (and the file will be
    /// written instead to the current working directory).
    pub fn with_assets_and_target(
        assets: impl IntoIterator<Item = Asset>,
        target: impl AsRef<Path>,
    ) -> Self {
        let mut this = Self::with_assets(assets);
        let path = target.as_ref();
        if path.is_dir() && path.exists() {
            this.target = Some(target.as_ref().to_path_buf());
        }
        this
    }

    /// Adds an `Asset` to include when generating the `.gitignore`
    /// file. If the `Asset` already exists, then this does nothing.
    pub fn add_asset(&mut self, asset: Asset) {
        if !self.assets.contains(&asset) {
            self.assets.push(asset);
        }
    }

    /// Returns the path where the output will be written by joining
    /// the path contained in the `target` field with the file name
    /// `.gitignore`.
    ///
    ///
    /// If the `target` field is not a directory, or is empty, then
    /// the current working directory will be used and will return an error if a
    /// valid current working directory cannot be obtained.
    pub fn get_target_path(&self) -> io::Result<PathBuf> {
        match self.target.as_ref() {
            Some(p) if p.is_dir() && p.exists() => Ok(p.join(Self::FILENAME)),
            _ => std::env::current_dir().map(|cwd| cwd.join(Self::FILENAME)),
        }
    }

    fn backup_if_exists(&self, path: &PathBuf) -> io::Result<()> {
        if path.exists() {
            // `<DIR>/.gitignore` exists, so we find out for what integer
            // `n` will `DIR/.gitignore.backup_n` not exist and rename
            // the existing file to that.
            let name = ".gitignore.backup_";
            let mut ct = 1;
            let mut target = path.clone();
            loop {
                let end = format!("{name}{}", ct);
                let p = target.with_file_name(end);
                if p.exists() {
                    ct += 1;
                    continue;
                } else {
                    target = p;
                    break;
                }
            }
            println!(
                "Backing up\n    `{}`\nto\n    `{}`",
                path.display(),
                target.display()
            );
            fs::rename(path, target)?;
        }
        Ok(())
    }

    /// Reads the content of all `Asset`s and, if there is at least
    /// one asset *and* no failures occurred, writes the aggregated
    /// content to a file named `.gitignore` in the directory
    /// described by the `target` field, returning the number of bytes
    /// written.
    ///
    /// If there are no `Asset`s included, then this does nothing and
    /// returns a result indicating zero bytes were written.
    ///
    /// If the `target` field is `None`, then uses the current working
    /// directory.
    ///
    /// If the final output path already exists, then it will make a
    /// backup of the existing file and overwrite it.
    pub fn write_to_target(&self) -> io::Result<usize> {
        let mut buf = String::new();
        buf.push_str("# GENERATED BY `ignore_me` COMMAND LINE UTILITY\n\n");
        let mut nonempty = false;
        for asset in self.assets.as_slice() {
            let contents = asset.contents()?;
            let name = asset.git_ignore().get_name();
            buf.push_str("# [");
            buf.push_str(name);
            buf.push_str("]\n");
            buf.push_str(contents.as_str());
            buf.push_str("\n\n");
            nonempty |= true;
        }
        let bytes_written = if nonempty {
            let path = self.get_target_path()?;
            self.backup_if_exists(&path)?;
            let total = buf.len();
            fs::write(path, buf)?;
            total
        } else {
            0
        };

        Ok(bytes_written)
    }
}
